# -*- coding: utf-8 -*-
"""РО_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IugReE7cUaI8ghkqy3bzCMDXgClV4m08
"""

import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator
import numpy as np
import math


class Self:
    _colors = ['blue', 'green', '#D00F7E']
    _clasters = []
    _p = []
    _C = []
    _M = []


def dB(self, x, i):
    C = self._C
    C_inv = np.linalg.inv(C[i])
    M = self._M
    x = np.array(x)

    lp = math.log(self._p[i])

    det = abs(np.linalg.det(C[i]))
    lC = math.log(det)

    xMit = (x - M[i]).transpose()
    x_Mi_Cinv = (x - M[i]) @ C_inv
    res = -0.5 * (x_Mi_Cinv @ xMit)
    return lp - 0.5 * lC + res


def koeffA(self, x, C):
    C_inv = np.linalg.inv(C) #обратная матрица
    return C_inv[1][1]


def koeffB(self, x, C, M):
    C_inv = np.linalg.inv(C)
    return (C_inv[0][1] + C_inv[1][0]) * (x - M[0]) - 2 * C_inv[1][1] * M[1]


def koeffC(self, x, C, M):
    c = np.linalg.inv(C)
    res = (c[0][1] + c[1][0]) * (M[0] * M[1] - x * M[1]) + c[0][0] * (x - M[0]) * (x - M[0]) + c[1][1] * M[1] * M[1]
    return res


def koeffD(self, p, C):
    det = abs(np.linalg.det(C))  # почему-то определитель матрицы мб отрицательным?
    return 2 * (math.log(p) - 0.5 * math.log(det))


def Bayes_classifier(self, classes):
    # считаем априорные вероятности p(wj) = Nj / N, где Nj - количество точек в кластере wj
    N = []
    sum = 0
    for claster in classes:
        claster_len = len(claster)
        N.append(claster_len)
        sum += claster_len
    p = []
    for Ni in N:
        p.append(float(Ni / sum)) #Ni-кол-во точек в кластере

    # считаем mj
    m = []
    m1 = []
    for j in range(len(N)):
        sum = [0, 0]
        Nj = N[j]
        for i in range(Nj):
            sum[0] += 1 / Nj * (classes[j][i][0])
            sum[1] += 1 / Nj * (classes[j][i][1])
        m.append(np.array([sum]))
        m1.append(np.array(sum))

    # считаем матрицу C
    C = []
    for j in range(len(N)):
        Nj = N[j]
        m = np.array(m)
        sum = np.array([[0, 0], [0, 0]]) # нулевой вектор 2*2
        for i in range(Nj):
            x = np.array([classes[j][i]])
            xt = x.transpose()
            xxt = xt @ x
            sum = sum + xxt * (1 / Nj) #добавляем x на x транспонированную делим на j класс
        mt = m[j].transpose()
        mult_m = np.array([[0, 0], [0, 0]])
        mult_m = mult_m + mt @ m[j]
        Cj = sum - mult_m # вычитаем произведение мат ожиданий
        C.append(Cj)
    self._C = C
    self._p = p
    self._M = m1
    self._clasters = classes
    DrawBorders(self)  # сразу рисуем личные границы каждого класса
    return (p, C, m)


def Duble(self, point):
    duble = False
    Dj= -10 ** (7)
    eps = 10
    for i in range(len(self._clasters)):
        curDi = dB(self, point, i)
        if abs(curDi - Dj) <= eps:
            duble = True
        if curDi - Dj > eps:
            duble = False
            Dj = curDi
    return duble # возвращает индекс точки


def claster(self, point):
    Dj = -10 ** (7)
    index = -1
    eps = 0.01
    clasters = self._clasters

    for i in range(len(clasters)):
        curDi = dB(self, point, i)
        if curDi - Dj > eps:
            Dj = curDi
            index = i

    return index


def DrawBorders(self):
    clasters = self._clasters
    p = self._p
    C = self._C
    M = self._M

    runner = 50
    x = -4
    while x < 10:
        for i in range(len(clasters)):
            Ai = koeffA(self, x, C[i])
            Bi = koeffB(self, x, C[i], M[i])
            Ci = koeffC(self, x, C[i], M[i])
            Di = koeffD(self, p[i], C[i])
            for j in range(i + 1, len(clasters)):
                Aj = koeffA(self, x, C[j])
                Bj = koeffB(self, x, C[j], M[j])
                Cj = koeffC(self, x, C[j], M[j])
                Dj = koeffD(self, p[j], C[i])
                if Ai == Aj:
                    y = (Ci - Cj - Di + Dj) / (Bi - Bj)
                    if Duble(self, [x, y]):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter([x, y], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='pink', s=2.5)
                else:
                    dd = (Bi - Bj) ** 2 - 4 * (Ai - Aj) * (Ci - Cj - Di + Dj)
                    dd = abs(dd)  # возникают отрицательные значения??
                    y = (-(Bi - Bj) + math.sqrt(dd)) / (2 * (Ai - Aj))
                    point = [x, y]
                    if Duble(self, point):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter(point[0], point[1], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='pink', s=2.5)
                    y = (-(Bi - Bj) - math.sqrt(dd)) / (2 * (Ai - Aj))
                    point = [x, y]
                    if Duble(self, point):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter(point[0], point[1], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='pink', s=2.5)
        x += 1 / runner


def on_press(self, x):
    index = claster(self, x)
    plt.scatter(x[0], x[1], color=self._colors[index])
    # self.canvas.axes.scatter(x[0],x[1], color = self._colors[index])
    # self.canvas.draw()


def main():
    figure = plt.figure()
    ax = figure.add_subplot()
    ax.xaxis.set_major_locator(MultipleLocator(base=1))
    ax.yaxis.set_major_locator(MultipleLocator(base=1))
    ax.set_aspect('equal', adjustable='box')
    ax.grid()
    clasters = [
        [[-2.61, 1.15], [-3.65, 0.33], [-2.9, 0.85], [-2.69, 0.89], [-2.37, 1.67], [-3.69, 0.54], [-3.19, 0.97]],
        [[9.67, 2.23], [8.9, 1.68], [8.38, 2.23], [9.26, 2.74], [9.1, 2.75], [9.24, 2.08], [8.93, 3.01]],
        [[3.38, 0.69], [2.82, 1.01], [3.34, 0.5], [3.1, 0.85], [3.2, 0.63], [3.36, 0.89], [3.01, 1.42]]
    ]
    colors = ['blue', 'green', '#D00F7E']

    for i in range(len(clasters)):
        for dot in clasters[i]:
            plt.scatter(dot[0], dot[1], color=colors[i], s=2)
    self = Self()
    p, c, M = Bayes_classifier(self, clasters)
    clasters = self._clasters
    p = self._p
    C = self._C
    M = self._M
    runner = 50
    x = -4
    while x < 10:
        for i in range(len(clasters)):
            Ai = koeffA(self, x, C[i])
            Bi = koeffB(self, x, C[i], M[i])
            Ci = koeffC(self, x, C[i], M[i])
            Di = koeffD(self, p[i], C[i])
            for j in range(i + 1, len(clasters)):
                Aj = koeffA(self, x, C[j])
                Bj = koeffB(self, x, C[j], M[j])
                Cj = koeffC(self, x, C[j], M[j])
                Dj = koeffD(self, p[j], C[i])
                if Ai == Aj:
                    y = (Ci - Cj - Di + Dj) / (Bi - Bj)
                    if Duble(self, [x, y]):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter([x, y], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='black', s=2.5)
                else:
                    dd = (Bi - Bj) ** 2 - 4 * (Ai - Aj) * (Ci - Cj - Di + Dj)
                    dd = abs(dd)  # возникают отрицательные значения??
                    y = (-(Bi - Bj) + math.sqrt(dd)) / (2 * (Ai - Aj))
                    point = [x, y]
                    if Duble(self, point):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter(point[0], point[1], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='black', s=2.5)
                    y = (-(Bi - Bj) - math.sqrt(dd)) / (2 * (Ai - Aj))
                    point = [x, y]
                    if Duble(self, point):
                        if y < 14 and y > -5:
                            # self.canvas.axes.scatter(point[0], point[1], color = 'purple', s = 1.3)
                            plt.scatter(x, y, color='black', s=2.5)
        x += 1 / runner

    x = [1, 4]
    index = claster(self, x)
    plt.scatter(x[0], x[1], color=self._colors[index])
    plt.show()


if __name__ == '__main__':
    main()